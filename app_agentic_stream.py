# app_agentic_stream.py (updated)
import os
import json
import shutil
import uuid
import re
import traceback
from pathlib import Path
from fastapi import FastAPI, UploadFile, File, Form
from fastapi.responses import StreamingResponse
from fastapi.middleware.cors import CORSMiddleware
from fastapi.staticfiles import StaticFiles

app = FastAPI()
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Mount static files
app.mount("/static", StaticFiles(directory="static"), name="static")

BASE_HOST = os.environ.get("API_BASE", "http://127.0.0.1:8000")
RESULTS_DIR = Path("static/results")
RESULTS_DIR.mkdir(parents=True, exist_ok=True)

@app.get("/")
async def root():
    return {"status": "CBCT AI Backend is running", "version": "1.0"}

@app.get("/health")
async def health_check():
    return {"status": "healthy"}

def sse_line(data: dict) -> str:
    return f"data: {json.dumps(data, ensure_ascii=False)}\n\n"

def make_packet(event_name: str, payload: dict):
    safe_payload = {}
    for k, v in (payload or {}).items():
        try:
            json.dumps({k: v})
            safe_payload[k] = v
        except Exception:
            safe_payload[k] = str(v)
    return {"event": event_name, "data": safe_payload}

def sanitize_filename(name: str) -> str:
    return re.sub(r"[^a-zA-Z0-9_\-\.]", "_", name)

def local_path_to_url(p: str):
    if not p:
        return None
    fname = os.path.basename(p)
    return f"{BASE_HOST}/static/results/{fname}"

@app.post("/generate_report_stream/")
async def generate_report_stream(file: UploadFile = File(...), conditions: str = Form("[]")):
    async def event_stream():
        try:
            # Parse conditions safely
            try:
                conds = json.loads(conditions)
                if not isinstance(conds, list):
                    conds = []
            except Exception:
                conds = []

            # UPLOADED
            yield sse_line(make_packet("uploaded", {"filename": file.filename}))
            
            # Save upload to a temp location
            uid = str(uuid.uuid4())
            tmp = Path(f"/tmp/cbct_upload_{uid}")
            tmp.mkdir(parents=True, exist_ok=True)
            safe_name = sanitize_filename(file.filename)
            saved = tmp / f"{uid}_{safe_name}"
            
            with open(saved, "wb") as f:
                shutil.copyfileobj(file.file, f)

            yield sse_line(make_packet("loading_cbct", {"message": f"File saved as {saved}"}))

            # Try to import and use the DICOM reader
            try:
                from dicom_reader import load_cbct_from_path
                cbct = load_cbct_from_path(str(saved))
                yield sse_line(make_packet("loaded_cbct", {"message": "CBCT loaded successfully"}))
            except Exception as e:
                yield sse_line(make_packet("error", {"message": f"DICOM reader failed: {str(e)}"}))
                return

            # Continue with the rest of your pipeline...
            yield sse_line(make_packet("detector", {"message": "Starting analysis"}))
            
            # Simulate some processing time
            import time
            for i in range(5):
                yield sse_line(make_packet("progress", {"step": i+1, "total": 5, "message": f"Processing step {i+1}/5"}))
                time.sleep(1)
            
            # Final report
            report_text = f"""CBCT AI Analysis Report

Patient: Test Patient
Study Date: 2024-01-01
File: {file.filename}

FINDINGS:
- Normal bony structures
- No significant pathologies detected
- Adequate airway space
- Normal sinus anatomy

IMPRESSIONS:
Within normal limits.

This is a test report generated by the CBCT AI system."""

            yield sse_line(make_packet("final_report", {"report_text": report_text}))
            yield sse_line(make_packet("complete", {"status": "success"}))

        except Exception as e:
            error_trace = traceback.format_exc()
            yield sse_line(make_packet("error", {"message": f"Pipeline failed: {str(e)}", "traceback": error_trace}))
            return

    return StreamingResponse(event_stream(), media_type="text/event-stream")